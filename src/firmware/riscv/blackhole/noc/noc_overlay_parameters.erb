<%-

msg_info_buf_size_words = 256
global_offset_table_size = 8

header = "\
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AUTO_GENERATED! DO NOT MODIFY!                                                                                              //
//                                                                                                                             //
// Please run                                                                                                                  //
//                                                                                                                             //
// (echo '<\% type=:svh_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > ../rtl/overlay/tt_noc_overlay_params.svh   //
// (echo '<\% type=:c_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.h                     //
// (echo '<\% type=:cpp_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.hpp                 //
// (echo '<\% type=:rb_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.rb                   //
// Open noc_overlay_parameters.hpp and move static class varaible definitions to noc_overlay_parameters.cpp                    //
// overriding existing ones.                                                                                                   //
//                                                                                                                             //
// to regenerate                                                                                                               //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
"
rb_header = "\
#################################################################################################################################
## AUTO_GENERATED! DO NOT MODIFY!                                                                                              ##
##                                                                                                                             ##
## Please run                                                                                                                  ##
##                                                                                                                             ##
## (echo '<\% type=:svh_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > ../rtl/overlay/tt_noc_overlay_params.svh   ##
## (echo '<\% type=:c_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.h                     ##
## (echo '<\% type=:cpp_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.hpp                 ##
## (echo '<\% type=:rb_header %\>' && cat noc_overlay_parameters.erb) | erb -T - > noc_overlay_parameters.rb                   ##
## Open noc_overlay_parameters.hpp and move static class varaible definitions to noc_overlay_parameters.cpp                    ##
## overriding existing ones.                                                                                                   ##
##                                                                                                                             ##
## to regenerate                                                                                                               ##
##                                                                                                                             ##
## Tenstorrent CONFIDENTIAL                                                                                                    ##
## __________________                                                                                                          ##
##                                                                                                                             ##
##  Tenstorrent Inc.                                                                                                           ##
##  All Rights Reserved.                                                                                                       ##
##                                                                                                                             ##
## NOTICE:  All information contained herein is, and remains                                                                   ##
## the property of Tenstorrent Inc.  The intellectual                                                                          ##
## and technical concepts contained                                                                                            ##
## herein are proprietary to Tenstorrent Inc.                                                                                  ##
## and may be covered by U.S., Canadian and Foreign Patents,                                                                   ##
## patents in process, and are protected by trade secret or copyright law.                                                     ##
## Dissemination of this information or reproduction of this material                                                          ##
## is strictly forbidden unless prior written permission is obtained                                                           ##
## from Tenstorrent Inc.                                                                                                       ##
#################################################################################################################################
"


registers = [
    # autocfg registers should be listed here
    # If they canot be configured by auto cfg they should be placed at the line starting with
    # "Non autocfg registers"

    # Always keep these two registers here due to hackery in tb_tensix that requires them in the first 32 indicies of address space.
    {
        :index => 0,
        :name => "STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO",
        :description  => "\
        // For endpoints with SOURCE_ENDPOINT == 1, this register is for firmware 
        // to register new message for sending. 
        // This updates the msg_info register structure directly, rather than writing to the message info
        // buffer in memory.
        // Must not be written when the message info register structure is full, or if
        // there are message info entries in the memory buffer. (This would cause a race
        // condition.)  
        ",
        :fields =>  [
            { :name => "SOURCE_ENDPOINT_NEW_MSG_ADDR", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "SOURCE_ENDPOINT_NEW_MSG_SIZE", :offset => "(SOURCE_ENDPOINT_NEW_MSG_ADDR+SOURCE_ENDPOINT_NEW_MSG_ADDR_WIDTH)", :width => "(32-MEM_WORD_ADDR_WIDTH-1)" },
            { :name => "SOURCE_ENDPOINT_NEW_MSG_LAST_TILE", :offset => "(SOURCE_ENDPOINT_NEW_MSG_SIZE+SOURCE_ENDPOINT_NEW_MSG_SIZE_WIDTH)", :width => "(1)" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NUM_MSGS_RECEIVED_INC",
        :description  => "\
        // For endpoints with SOURCE_ENDPOINT == 1, this register is for firmware 
        // to update the number of messages whose data & header are available in the memory buffer.
        // Hardware register is incremented atomically if sending of previous messages is in progress. 
        ",
        :fields =>  [
            { :name => "SOURCE_ENDPOINT_NEW_MSGS_NUM", :offset => "0", :width => "12" },
            { :name => "SOURCE_ENDPOINT_NEW_MSGS_TOTAL_SIZE", :offset => "(SOURCE_ENDPOINT_NEW_MSGS_NUM+SOURCE_ENDPOINT_NEW_MSGS_NUM_WIDTH)", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "SOURCE_ENDPOINT_NEW_MSGS_LAST_TILE", :offset => "(SOURCE_ENDPOINT_NEW_MSGS_TOTAL_SIZE+SOURCE_ENDPOINT_NEW_MSGS_TOTAL_SIZE_WIDTH)", :width => "1" },
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_ONETIME_MISC_CFG",
        :description  => "\
        // Registers that need to be programmed once per blob. (Can apply to multiple phases.)
        //   * Phase/data forward options:
        //      PHASE_AUTO_CONFIG = set to 1 for stream to fetch next phase configuration automatically.
        //      PHASE_AUTO_ADVANCE = set to 1 for stream to advance to next phase automatically 
        //            (otherwise need to write STREAM_PHASE_ADVANCE below)
        ",
        :fields =>  [
            { :name => "PHASE_AUTO_CONFIG", :offset => "0", :width => "1" },
            { :name => "PHASE_AUTO_ADVANCE", :offset => "(PHASE_AUTO_CONFIG+PHASE_AUTO_CONFIG_WIDTH)", :width => "1" },
            { 
                :name => "REG_UPDATE_VC_REG", :offset => "(PHASE_AUTO_ADVANCE+PHASE_AUTO_ADVANCE_WIDTH)", :width => "3",
                :description  => "\
                // set to one of the values (0-5) to select which VC control flow updates will be sent on
                ",

            },
            {
                :name => "GLOBAL_OFFSET_TABLE_RD_SRC_INDEX", :offset => "(REG_UPDATE_VC_REG+REG_UPDATE_VC_REG_WIDTH)", :width => "GLOBAL_OFFSET_TABLE_SIZE_WIDTH",
                :description  => "\
                // Read index of global offset table, which will offset o_data_fwd_src_addr by entry value.
                ",
            },
            {
                :name => "GLOBAL_OFFSET_TABLE_RD_DEST_INDEX", :offset => "(GLOBAL_OFFSET_TABLE_RD_SRC_INDEX+GLOBAL_OFFSET_TABLE_RD_SRC_INDEX_WIDTH)", :width => "GLOBAL_OFFSET_TABLE_SIZE_WIDTH",
                :description  => "\
                // Read index of global offset table, which will offset o_data_fwd_dest_addr by entry value.
                ",
            },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MISC_CFG",
        :description  => "\
        // The ID of NOCs used for incoming and outgoing data, followed by misc. stream configuration options:
        //   * Source - set exactly one of these to 1:
        //        SOURCE_ENDPOINT = source is local math/packer
        //        REMOTE_SOURCE = source is remote sender stream
        //        LOCAL_SOURCES_CONNECTED = source is one or more local connected streams
        //   * Destination - set one or zero of these to 1:
        //        RECEIVER_ENDPOINT = stream is read by local unpacker/math
        //        REMOTE_RECEIVER = stream forwards data to a remote destination or multicast group
        //        LOCAL_RECEIVER = stream is connected to a local destination stream
        //        None set = stream just stores data in a local buffer, without forwarding/clearing, and 
        //                   finishes the phase once all messages have been received
        ",
        :fields =>  [
            { :name => "INCOMING_DATA_NOC", :offset => "0", :width => "NOC_NUM_WIDTH" },
            { :name => "OUTGOING_DATA_NOC", :offset => "(INCOMING_DATA_NOC+INCOMING_DATA_NOC_WIDTH)", :width => "NOC_NUM_WIDTH" },
            { :name => "REMOTE_SRC_UPDATE_NOC", :offset => "(OUTGOING_DATA_NOC+OUTGOING_DATA_NOC_WIDTH)", :width => "NOC_NUM_WIDTH" },
            { :name => "LOCAL_SOURCES_CONNECTED", :offset => "(REMOTE_SRC_UPDATE_NOC+REMOTE_SRC_UPDATE_NOC_WIDTH)", :width => "1" },
            { :name => "SOURCE_ENDPOINT", :offset => "(LOCAL_SOURCES_CONNECTED+LOCAL_SOURCES_CONNECTED_WIDTH)", :width => "1" },
            { :name => "REMOTE_SOURCE", :offset => "(SOURCE_ENDPOINT+SOURCE_ENDPOINT_WIDTH)", :width => "1" },
            { :name => "RECEIVER_ENDPOINT", :offset => "(REMOTE_SOURCE+REMOTE_SOURCE_WIDTH)", :width => "1" },
            { :name => "LOCAL_RECEIVER", :offset => "(RECEIVER_ENDPOINT+RECEIVER_ENDPOINT_WIDTH)", :width => "1" },
            { :name => "REMOTE_RECEIVER", :offset => "(LOCAL_RECEIVER+LOCAL_RECEIVER_WIDTH)", :width => "1" },
            { :name => "TOKEN_MODE", :offset => "(REMOTE_RECEIVER+REMOTE_RECEIVER_WIDTH)", :width => "1" },
            { :name => "COPY_MODE", :offset => "(TOKEN_MODE+TOKEN_MODE_WIDTH)", :width => "1" },
            { :name => "NEXT_PHASE_SRC_CHANGE", :offset => "(COPY_MODE+COPY_MODE_WIDTH)", :width => "1" },
            { :name => "NEXT_PHASE_DEST_CHANGE", :offset => "(NEXT_PHASE_SRC_CHANGE+NEXT_PHASE_SRC_CHANGE_WIDTH)", :width => "1" },
            { 
                :name => "DATA_BUF_NO_FLOW_CTRL", :offset => "(NEXT_PHASE_DEST_CHANGE+NEXT_PHASE_DEST_CHANGE_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_SOURCE==1 and the buffer is large enough to accept full phase data without wrapping:
                ",
            },
            { 
                :name => "DEST_DATA_BUF_NO_FLOW_CTRL", :offset => "(DATA_BUF_NO_FLOW_CTRL+DATA_BUF_NO_FLOW_CTRL_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_RECEIVER==1 and the destination buffer is large enough to accept full phase data without wrapping:
                ",
            },
            { 
                :name => "MSG_INFO_BUF_FLOW_CTRL", :offset => "(DEST_DATA_BUF_NO_FLOW_CTRL+DEST_DATA_BUF_NO_FLOW_CTRL_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_SOURCE==1 and you want the buffer to have wrapping:
                ",
            },
            { 
                :name => "DEST_MSG_INFO_BUF_FLOW_CTRL", :offset => "(MSG_INFO_BUF_FLOW_CTRL+MSG_INFO_BUF_FLOW_CTRL_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_RECEIVER==1 and you want the destination buffer to have wrapping:
                ",
            },
            { 
                :name => "REMOTE_SRC_IS_MCAST", :offset => "(DEST_MSG_INFO_BUF_FLOW_CTRL+DEST_MSG_INFO_BUF_FLOW_CTRL_WIDTH)", :width => "1",
                :description  => "\
                // set if REMOTE_SOURCE==1 and has mulicast enabled (i.e. this stream is part of a multicast group)
                ",
            },
            { 
                :name => "NO_PREV_PHASE_OUTGOING_DATA_FLUSH", :offset => "(REMOTE_SRC_IS_MCAST+REMOTE_SRC_IS_MCAST_WIDTH)", :width => "1",
                :description  => "\
                // set if no need to flush outgoing remote data from previous phase 
                ",
            },
            {
                :name => "SRC_FULL_CREDIT_FLUSH_EN", :offset => "(NO_PREV_PHASE_OUTGOING_DATA_FLUSH+NO_PREV_PHASE_OUTGOING_DATA_FLUSH_WIDTH)", :width => "1",
                :description  => "\
                // Set to one to enable full credit flushing on src side
                ",
            },
            {
                :name => "DST_FULL_CREDIT_FLUSH_EN", :offset => "(SRC_FULL_CREDIT_FLUSH_EN+SRC_FULL_CREDIT_FLUSH_EN_WIDTH)", :width => "1",
                :description  => "\
                // Set to one to enable full credit flushing on dest side
                ",
            },
            {
                :name => "INFINITE_PHASE_EN", :offset => "(DST_FULL_CREDIT_FLUSH_EN+DST_FULL_CREDIT_FLUSH_EN_WIDTH)", :width => "1",
                :description  => "\
                // Set to one to enable infinite messages per phase, accompanied by a last tile header bit which will end the phase
                ",
            },
            {
                :name => "OOO_PHASE_EXECUTION_EN", :offset => "(INFINITE_PHASE_EN+INFINITE_PHASE_EN_WIDTH)", :width => "1",
                :description  => "\
								// Enables out-of-order phase execution by providing an array of size num_tiles at the end of phase blob, with order in which each tile should be sent. Each array entry contains a 17-bit tile address and a 15-bit tile size.
                ",
            },
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_SRC",
        :description  => "\
        // Properties of the remote source stream (coorindates, stream ID, and this streams destination index).
        // Dont-care unless REMOTE_SOURCE == 1.
        ",
        :fields =>  [
            { :name => "STREAM_REMOTE_SRC_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_SRC_Y", :offset => "(STREAM_REMOTE_SRC_X+STREAM_REMOTE_SRC_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "REMOTE_SRC_STREAM_ID", :offset => "(STREAM_REMOTE_SRC_Y+STREAM_REMOTE_SRC_Y_WIDTH)", :width => "STREAM_ID_WIDTH" },
            { :name => "STREAM_REMOTE_SRC_DEST_INDEX", :offset => "(REMOTE_SRC_STREAM_ID+REMOTE_SRC_STREAM_ID_WIDTH)", :width => "STREAM_ID_WIDTH" },
            { :name => "DRAM_READS__TRANS_SIZE_WORDS_LO", :offset => "(STREAM_REMOTE_SRC_Y+STREAM_REMOTE_SRC_Y_WIDTH)", :width => "12" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_SRC_PHASE",
        :description  => "\
        // Remote source phase (may be different from the destination stream phase.)
        // We use 20-bit phase ID, so phase count doesnt wrap until 1M phases. 
        // Dont-care unless REMOTE_SOURCE == 1. 
        ",
        :fields =>  [
            { :name => "DRAM_READS__SCRATCH_1_PTR", :offset => "0", :width => "19" },
            { :name => "DRAM_READS__TRANS_SIZE_WORDS_HI", :offset => "(DRAM_READS__SCRATCH_1_PTR+DRAM_READS__SCRATCH_1_PTR_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MEM_BUF_SPACE_AVAILABLE_ACK_THRESHOLD",
        :description  => "\
        // 4-bit wide register that determines the threshold at which a stream
        // with remote source sends an update message to STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE.
        // Dont-care unless REMOTE_SOURCE==1.  
        // Values:
        //   value[3:0] == 0 => disable threshold. Acks send as soon as any data are cleared/forwarded. 
        //   value[3:0] >  0 => threshold calculated according to the following formula:
        //         if (value[3])
        //              threshold = buf_size - (buf_size >> value[2:0])
        //         else 
        //              threshold = (buf_size >> value[2:0])
        //
        // This enables setting thresholds of buf_size/2, buf_size/4, buf_size/8, ... buf_size/256, 
        // as well as  3*buf_size/4, 7*buf_size/8, etc. 
        ",
        :fields =>  [
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST",
        :description  => "\
        // Properties of the remote destination stream (coorindates, stream ID).  Dont-care unless REMOTE_RECEIVER == 1.
        // If destination is multicast, this register specifies the starting coordinates of the destination
        // multicast group/rectangle. (The end coordinates are in STREAM_MCAST_DEST below.)
        ",
        :fields =>  [
            { :name => "STREAM_REMOTE_DEST_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_DEST_Y", :offset => "(STREAM_REMOTE_DEST_X+STREAM_REMOTE_DEST_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_DEST_STREAM_ID", :offset => "(STREAM_REMOTE_DEST_Y+STREAM_REMOTE_DEST_Y_WIDTH)", :width => "STREAM_ID_WIDTH" },
        ],
    },
    {
        :index => :same_as_prev,
        :name => "STREAM_LOCAL_DEST",
        :description  => "\
        // Properties of the local destination gather stream connection.
        // Dont-care unless LOCAL_RECEIVER == 1.
        // Shares register space with STREAM_REMOTE_DEST_REG_INDEX.
        ",
        :fields =>  [
            { :name => "STREAM_LOCAL_DEST_MSG_CLEAR_NUM", :offset => "0", :width => "12" },
            { :name => "STREAM_LOCAL_DEST_STREAM_ID", :offset => "(STREAM_LOCAL_DEST_MSG_CLEAR_NUM+STREAM_LOCAL_DEST_MSG_CLEAR_NUM_WIDTH)", :width => "STREAM_ID_WIDTH" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_BUF_START",
        :description  => "\
        // Start address (in words) of the remote destination stream memory buffer. 
        ",
        :fields =>  [
            { :name => "DRAM_WRITES__SCRATCH_1_PTR_LO", :offset => "0", :width => "16" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_BUF_START_HI",
        :description  => "\
        // High bits for STREAM_REMOTE_DEST_BUF_START
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_BUF_SIZE",
        :description  => "\
        // Size (in words) of the remote destination stream memory buffer. 
        ",
        :fields =>  [
            { :name => "REMOTE_DEST_BUF_SIZE_WORDS", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "DRAM_WRITES__SCRATCH_1_PTR_HI", :offset => "0", :width => "3" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_WR_PTR",
        :description  => "\
        // Write pointer for the remote destination stream memory buffer. 
        // Can be written directly; automatically reset to 0 when 
        // STREAM_REMOTE_DEST_BUF_START is written.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_BUF_SIZE",
        :description  => "\
        // Size (in power2) of the remote destination stream memory buffer. 
        // Bits encode powers of 2 sizes in words (2^(x+1)), e.g. 0 -> 2 words, 1 -> 4 words, 7 -> 256 words
        // Max 256 word size.
        // Only used when DEST_MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
            { :name => "REMOTE_DEST_MSG_INFO_BUF_SIZE_POW2", :offset => "0", :width => "MSG_INFO_BUF_SIZE_POW_BITS" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_BUF_START",
        :description  => "\
        // Start address (in words) of the remote destination stream memory buffer. 
        // Only used when DEST_MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
        ],
    },
    {
        :index => :same_as_prev,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_WR_PTR",
        :description  => "\
        // Write pointer for the remote destination message info buffer. 
        // Dont-care unless REMOTE_RECEIVER==1. 
        // Needs to be initialized to the start of the message info buffer of the remote destination
        // at phase start, if destination is changed. 
        // Subsequently its incremented automatically as messages are forwarded. 
        // When DEST_MSG_INFO_BUF_FLOW_CTRL is true this pointer is the one above
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_BUF_START_HI",
        :description  => "\
        // High bits for STREAM_REMOTE_DEST_MSG_INFO_BUF_START
        // Only used when DEST_MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
        ],
    },
    {
        :index => :same_as_prev,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_WR_PTR_HI",
        :description  => "\
        // High bits for STREAM_REMOTE_DEST_MSG_INFO_WR_PTR
        // When DEST_MSG_INFO_BUF_FLOW_CTRL is true this pointer is the one above
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_MSG_INFO_WRAP_WR_PTR",
        :description  => "\
        // Only used when DEST_MSG_INFO_BUF_FLOW_CTRL is true
        // Write pointer for the remote destination message info buffer. 
        // Dont-care unless REMOTE_RECEIVER==1. 
        // Subsequently its incremented automatically as messages are forwarded. 
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_TRAFFIC",
        :description  => "\
        // Priority for traffic sent to remote destination. 
        // Valid only for streams capable of remote sending. 
        // 4-bit value. 
        // Set to 0 to send traffic under round-robin arbitration. 
        // Set to 1-15 for priority arbitration (higher values are higher priority).
        ",
        :fields =>  [
            { :name => "NOC_PRIORITY", :offset => "0", :width => "4" },
            { 
                :name => "UNICAST_VC_REG", :offset => "(NOC_PRIORITY+NOC_PRIORITY_WIDTH)", :width => "3",
                :description  => "\
                // set to one of the values (0-5) to select which VC unicast requests will be sent on
                ",
            },
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_BUF_START",
        :description  => "\
        // Start address (in words) of the memory buffer associated with this stream. 
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_BUF_SIZE",
        :description  => "\
        // Stream buffer size (in words). 
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_RD_PTR",
        :description  => "\
        // Read pointer value (word offset relative to buffer start).
        // Can be updated by writing the register. 
        // Value does not guarantee that all data up to the current value have been sent
        // off (forwarding command may be  ongoing).  To find out free space in the buffer,
        // read STREAM_BUF_SPACE_AVAILABLE. 
        // Automatically reset to 0 when STREAM_BUF_START_REG is updated. 
        ",
        :fields =>  [
            { :name => "STREAM_RD_PTR_VAL", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "STREAM_RD_PTR_WRAP", :offset => "(STREAM_RD_PTR_VAL+STREAM_RD_PTR_VAL_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_WR_PTR",
        :description  => "\
        // Write pointer value (word offset relative to buffer start). 
        // Can be read to determine the location at which to write new data. 
        // Can be updated by writing the register. 
        // In normal operation, should be updated only by writing 
        // STREAM_NUM_MSGS_RECEIVED_INC_REG or STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO_REG.
        ",
        :fields =>  [
            { :name => "STREAM_WR_PTR_VAL", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "STREAM_WR_PTR_WRAP", :offset => "(STREAM_WR_PTR_VAL+STREAM_WR_PTR_VAL_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_BUF_SIZE",
        :description  => "\
        // Size (in power2) of the remote destination stream memory buffer. 
        // Bits encode powers of 2 sizes in words (2^(x+1)), e.g. 0 -> 2 words, 1 -> 4 words, 7 -> 256 words
        // Max 256 word size.
        // Only used when MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
            { :name => "MSG_INFO_BUF_SIZE_POW2", :offset => "0", :width => "MSG_INFO_BUF_SIZE_POW_BITS" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_BUF_START",
        :description  => "\
        // Start address (in words) of the msg info buffer. 
        // Only used when MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
        ],
    },
    {
        :index => :same_as_prev,
        :name => "STREAM_MSG_INFO_PTR",
        :description  => "\
        // Stream message info buffer address. 
        //
        // This register needs to be initialized to the start of the message info buffer during 
        // phase configuration.  Subsequently it will be incremented by hardware as data are read
        // from the buffer, thus doubling as the read pointer during phase execution. 
        //
        // Stream hardware will assume that this buffer is large enough to hold info for all messages
        // within a phase, so unlike the buffer, it never needs to wrap.
        // 
        // The buffer is filled automatically by snooping for streams with remote source. 
        // For source enpoints, the buffer is written explicitly (along with the data buffer), after which 
        // STREAM_NUM_MSGS_RECEIVED_INC is written to notify the stream that messages are available for
        // sending. 
        // 
        // Write pointer is also managed automatically by hardware, but can be read or reset using 
        // STREAM_MSG_INFO_WR_PTR_REG. Write pointer is also reset when writing this register. 
        // When MSG_INFO_BUF_FLOW_CTRL is true this pointer is the one above
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_WRAP_RD_WR_PTR",
        :description  => "\
        // The read and write pointers for the msg info buffer when the message info buffer is in wrapping mode.
        // Only used when MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
            { :name => "STREAM_MSG_INFO_WRAP_RD_PTR", :offset => "0", :width => "MSG_INFO_BUF_SIZE_BITS" },
            { :name => "STREAM_MSG_INFO_WRAP_RD_PTR_WRAP", :offset => "(STREAM_MSG_INFO_WRAP_RD_PTR+STREAM_MSG_INFO_WRAP_RD_PTR_WIDTH)", :width => "1" },
            { :name => "STREAM_MSG_INFO_WRAP_WR_PTR", :offset => "(STREAM_MSG_INFO_WRAP_RD_PTR_WRAP+STREAM_MSG_INFO_WRAP_RD_PTR_WRAP_WIDTH)", :width => "MSG_INFO_BUF_SIZE_BITS" },
            { :name => "STREAM_MSG_INFO_WRAP_WR_PTR_WRAP", :offset => "(STREAM_MSG_INFO_WRAP_WR_PTR+STREAM_MSG_INFO_WRAP_WR_PTR_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :same_as_prev,
        :name => "STREAM_MSG_INFO_WR_PTR",
        :description  => "\
        // Write pointer value for message info buffer (absolute word address). 
        // In normal operation, should be updated only by writing 
        // STREAM_NUM_MSGS_RECEIVED_INC_REG or STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO_REG.
        // When MSG_INFO_BUF_FLOW_CTRL is true this pointer is the one above
        ",
        :fields =>  [
        ],
    },
    
    {
        :index => :prev_plus_1,
        :name => "STREAM_MCAST_DEST",
        :description  => "\
        // Destination spec for multicasting streams. STREAM_MCAST_END_X/Y are
        // the end coordinate for the multicast rectangle, with the ones from 
        // STREAM_REMOTE_DEST taken as start. 
        // Dont-care if STREAM_MCAST_EN == 0. 
        ",
        :fields =>  [
            { :name => "STREAM_MCAST_END_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_MCAST_END_Y", :offset => "(STREAM_MCAST_END_X+STREAM_MCAST_END_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_MCAST_EN", :offset => "(STREAM_MCAST_END_Y+STREAM_MCAST_END_Y_WIDTH)", :width => "1" },
            { :name => "STREAM_MCAST_LINKED", :offset => "(STREAM_MCAST_EN+STREAM_MCAST_EN_WIDTH)", :width => "1" },
            { 
                :name => "STREAM_MCAST_VC", :offset => "(STREAM_MCAST_LINKED+STREAM_MCAST_LINKED_WIDTH)", :width => "1",
                :description  => "\
                // Set to 0 to select VC 4, and 1 to select VC 5 (default 0)
                ",
            },
            { :name => "STREAM_MCAST_NO_PATH_RES", :offset => "(STREAM_MCAST_VC+STREAM_MCAST_VC_WIDTH)", :width => "1" },
            { :name => "STREAM_MCAST_XY", :offset => "(STREAM_MCAST_NO_PATH_RES+STREAM_MCAST_NO_PATH_RES_WIDTH)", :width => "1" },
            { :name => "STREAM_MCAST_SRC_SIDE_DYNAMIC_LINKED", :offset => "(STREAM_MCAST_XY+STREAM_MCAST_XY_WIDTH)", :width => "1" },
            { :name => "STREAM_MCAST_DEST_SIDE_DYNAMIC_LINKED", :offset => "(STREAM_MCAST_SRC_SIDE_DYNAMIC_LINKED+STREAM_MCAST_SRC_SIDE_DYNAMIC_LINKED_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MCAST_DEST_NUM",
        :description  => "\
        // Number of multicast destinations (dont-care for non-multicast streams)
        ",
        :fields =>  [
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_GATHER",
        :description  => "\
        // Specifies MSG_ARB_GROUP_SIZE. Valid values are 1 (round-robin
        // arbitration between each incoming stream) or 4 (round-robin arbitration
        // between groups of 4 incoming streams).  
        // Msg_LOCAL_STREAM_CLEAR_NUM specifies the number of messages that should 
        // be cleared from a gather stream before moving onto the next stream. 
        // When MSG_ARB_GROUP_SIZE > 1, the order of clearing the streams can be selected
        // with MSG_GROUP_STREAM_CLEAR_TYPE. 0 = clear the whole group MSG_LOCAL_STREAM_CLEAR_NUM times,
        // 1 = clear each stream of the group MSG_LOCAL_STREAM_CLEAR_NUM times before
        // moving onto the next stream in the group.
        ",
        :fields =>  [
            { :name => "MSG_LOCAL_STREAM_CLEAR_NUM", :offset => "0", :width => "12" },
            { :name => "MSG_GROUP_STREAM_CLEAR_TYPE", :offset => "(MSG_LOCAL_STREAM_CLEAR_NUM+MSG_LOCAL_STREAM_CLEAR_NUM_WIDTH)", :width => "1" },
            { :name => "MSG_ARB_GROUP_SIZE", :offset => "(MSG_GROUP_STREAM_CLEAR_TYPE+MSG_GROUP_STREAM_CLEAR_TYPE_WIDTH)", :width => "3" },
            { :name => "MSG_SRC_IN_ORDER_FWD", :offset => "(MSG_ARB_GROUP_SIZE+MSG_ARB_GROUP_SIZE_WIDTH)", :width => "1" },
            { :name => "MSG_SRC_ARBITRARY_CLEAR_NUM_EN", :offset => "(MSG_SRC_IN_ORDER_FWD+MSG_SRC_IN_ORDER_FWD_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_SRC_IN_ORDER_FWD_NUM_MSGS",
        :description  => "\
        // When using in-order message forwarding, number of messages after which the source
        // pointer goes back to zero (without phase change).
        // Dont-care if STREAM_MCAST_EN == 0 or MSG_SRC_IN_ORDER_FWD == 0. 
        ",
        :fields =>  [
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_CURR_PHASE_BASE",
        :description  => "\
        // Actual phase number executed is STREAM_CURR_PHASE_BASE_REG_INDEX + STREAM_CURR_PHASE_REG_INDEX
        // When reprogramming this register you must also reprogram STREAM_CURR_PHASE_REG_INDEX and STREAM_REMOTE_SRC_PHASE_REG_INDEX
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_CURR_PHASE",
        :description  => "\
        // Current phase number executed by the stream. 
        ",
        :fields =>  [
        ],
    },


    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_AUTO_CFG_PTR_BASE",
        :description  => "\
        // Actual address accessed will be STREAM_PHASE_AUTO_CFG_PTR_BASE_REG_INDEX + STREAM_PHASE_AUTO_CFG_PTR_REG_INDEX
        // When reprogramming this register you must also reprogram STREAM_PHASE_AUTO_CFG_PTR_REG_INDEX
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_AUTO_CFG_PTR",
        :description  => "\
        // Pointer to the stream auto-config data. Initialized to the start of
        // the auto-config structure at workload start, automatically updated
        // subsequenty. 
        // Specified as byte address, needs to be multiple of 4B.  
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_RELOAD_PHASE_BLOB",
        :description  => "\
        // This register acts as indirection to execute a phase that already exists somewhere in the blob.
        // It can be used to compress the blob when many phases need to be repeated.
        // When this register is written with a signed offset, the blob at address (auto_cfg pointer + offset) will be loaded.
        // The loaded blob must manually set its phase (using STREAM_CURR_PHASE) for this feature to work correctly.
        // Furthermore the phase after the reload blob phase must also set its current phase manually.
        ",
        :fields =>  [
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_HEADER_FORMAT",
        :description  => "\
        // Offset & size of the size field in the message header. Only valid offsets are multiples of 8
        // (i.e. byte-aligned). 
        ",
        :fields =>  [
            { :name => "MSG_HEADER_WORD_CNT_OFFSET", :offset => "0", :width => "MEM_WORD_BIT_OFFSET_WIDTH" },
            { :name => "MSG_HEADER_WORD_CNT_BITS", :offset => "(MSG_HEADER_WORD_CNT_OFFSET+MSG_HEADER_WORD_CNT_OFFSET_WIDTH)", :width => "MEM_WORD_BIT_OFFSET_WIDTH" },
            { :name => "MSG_HEADER_INFINITE_PHASE_LAST_TILE_OFFSET", :offset => "(MSG_HEADER_WORD_CNT_BITS+MSG_HEADER_WORD_CNT_BITS_WIDTH)", :width => "MEM_WORD_BIT_OFFSET_WIDTH" },
        ],
    },
    
    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_AUTO_CFG_HEADER",
        :description  => "\
        // Register corresponding to the auto-configuration header. Written by each auto-config access
        // at phase start, can be also written by software for initial configuration or if auto-config
        // is disabled. 
        // PHASE_NUM_INCR is phase number increment relative to the previous executed phase (or 0 right
        // after reset). The increment happens after auto-config is done, and before the phase is executed.
        // (Therefore reading  STREAM_CURR_PHASE_REG while auto-config is ongoing, or if it hasnt started
        // yet, may return the old phase number.)
        // This enables up to 2^12-1 phases to be skipped. If more phases need to be skipped, it is
        // necessary to insert an intermediate phase with zero messages, whose only purpose is to provide
        // an additional skip offset. 
        ",
        :fields =>  [
            { :name => "PHASE_NUM_INCR", :offset => "0", :width => "12" },
            { :name => "CURR_PHASE_NUM_MSGS", :offset => "(PHASE_NUM_INCR+PHASE_NUM_INCR_WIDTH)", :width => "12" },
            { :name => "NEXT_PHASE_NUM_CFG_REG_WRITES", :offset => "(CURR_PHASE_NUM_MSGS+CURR_PHASE_NUM_MSGS_WIDTH)", :width => "8" },
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_PERF_CONFIG",
        :description  => "\
        // Should be written only for stream 0, applies to all streams. 
        ",
        :fields =>  [
            { :name => "CLOCK_GATING_EN", :offset => "0", :width => "1" },
            { :name => "CLOCK_GATING_HYST", :offset => "(CLOCK_GATING_EN+CLOCK_GATING_EN_WIDTH)", :width => "7" },
            { 
                :name => "PARTIAL_SEND_WORDS_THR", :offset => "(CLOCK_GATING_HYST+CLOCK_GATING_HYST_WIDTH)", :width => "8",
                :description  => "\
                // PARTIAL_SEND_WORDS_THR contols the minimum number of 16-byte words of a tile to accumulate in a relay stream before sending it off to the destination.
                // If the size of the tile is less than or equal to PARTIAL_SEND_WORDS_THR, then this feild is ignored.
                // Default is 16 words
                ",
            },
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH",
        :description  => "\
        // Scratch registers
        // Exists only in streams 0-3 and 8-11
        // Data can be stored at [23:0] from STREAM_SCRATCH_REG_INDEX + 0 to STREAM_SCRATCH_REG_INDEX + 5
        // Can be loaded through overlay blobs.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :same_as_prev,
        :name => "STREAM_SCRATCH_0",
        :description  => "",
        :fields =>  [
            { :name => "NCRISC_TRANS_EN", :offset => "0", :width => "1" },
            { :name => "NCRISC_TRANS_EN_IRQ_ON_BLOB_END", :offset => "(NCRISC_TRANS_EN + NCRISC_TRANS_EN_WIDTH)", :width => "1" },
            { :name => "NCRISC_CMD_ID", :offset => "(NCRISC_TRANS_EN_IRQ_ON_BLOB_END + NCRISC_TRANS_EN_IRQ_ON_BLOB_END_WIDTH)", :width => "3" },
            { 
                :name => "NEXT_NRISC_PIC_INT_ON_PHASE", :offset => "(NCRISC_CMD_ID + NCRISC_CMD_ID_WIDTH)", :width => "19",
                :description  => "\
                // Kept for compatibility with grayskull, but doesnt not exist anymore in wormhole
                ",
            },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_1",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_RD_PTR_WORDS_LO", :offset => "0", :width => "24" },
            { :name => "NCRISC_LOOP_COUNT", :offset => "0", :width => "24" },
            { :name => "NCRISC_INIT_ENABLE_BLOB_DONE_IRQ", :offset => "0", :width => "1" },
            { :name => "NCRISC_INIT_DISABLE_BLOB_DONE_IRQ", :offset => "(NCRISC_INIT_ENABLE_BLOB_DONE_IRQ + NCRISC_INIT_ENABLE_BLOB_DONE_IRQ_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_2",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_RD_PTR_WORDS_HI", :offset => "0", :width => "4" },
            { :name => "DRAM_FIFO_WR_PTR_WORDS_LO", :offset => "(DRAM_FIFO_RD_PTR_WORDS_HI + DRAM_FIFO_RD_PTR_WORDS_HI_WIDTH)", :width => "20" },
            { :name => "NCRISC_TOTAL_LOOP_ITER", :offset => "0", :width => "24" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_3",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_WR_PTR_WORDS_HI", :offset => "0", :width => "8" },
            { :name => "DRAM_FIFO_CAPACITY_PTR_WORDS_LO", :offset => "(DRAM_FIFO_WR_PTR_WORDS_HI + DRAM_FIFO_WR_PTR_WORDS_HI_WIDTH)", :width => "16" },
            { :name => "NCRISC_LOOP_INCR", :offset => "0", :width => "16" },
            { :name => "NCRISC_LOOP_BACK_NUM_CFG_REG_WRITES", :offset => "(NCRISC_LOOP_INCR+NCRISC_LOOP_INCR_WIDTH)", :width => "8" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_4",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_CAPACITY_PTR_WORDS_HI", :offset => "0", :width => "12" },
            { :name => "DRAM_FIFO_BASE_ADDR_WORDS_LO", :offset => "(DRAM_FIFO_CAPACITY_PTR_WORDS_HI + DRAM_FIFO_CAPACITY_PTR_WORDS_HI_WIDTH)", :width => "12" },
            { :name => "NCRISC_LOOP_BACK_AUTO_CFG_PTR", :offset => "0", :width => "24" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SCRATCH_5",
        :description  => "",
        :fields =>  [
            { :name => "DRAM_FIFO_BASE_ADDR_WORDS_HI", :offset => "0", :width => "16" },
            { 
                :name => "DRAM_EN_BLOCKING", :offset => "(DRAM_FIFO_BASE_ADDR_WORDS_HI + DRAM_FIFO_BASE_ADDR_WORDS_HI_WIDTH)", :width => "1",
                :description  => "\
                // Processes the read or write operation to completeion without processing other dram streams in the meantime
                ",
            },
            { 
                :name => "DRAM_DATA_STRUCTURE_IS_LUT", :offset => "(DRAM_EN_BLOCKING + DRAM_EN_BLOCKING_WIDTH)", :width => "1",
                :description  => "\
                // Fifo structure in dram holds a dram pointer and size that is used as indirection to a tile in dram
                ",
            },
            { 
                :name => "DRAM_RESET_RD_PTR_TO_BASE_ON_EMPTY", :offset => "(DRAM_DATA_STRUCTURE_IS_LUT + DRAM_DATA_STRUCTURE_IS_LUT_WIDTH)", :width => "1",
                :description  => "\
                // During a dram read, if its detected that the fifo is empty the ncrisc will reset the read pointer back to base
                // Its expected that there is no host interaction
                ",
            },
            { 
                :name => "DRAM_RESET_WR_PTR_TO_BASE_ON_FULL", :offset => "(DRAM_RESET_RD_PTR_TO_BASE_ON_EMPTY + DRAM_RESET_RD_PTR_TO_BASE_ON_EMPTY_WIDTH)", :width => "1",
                :description  => "\
                // During a dram write, if its detected that the fifo is full the ncrisc will reset the write pointer back to base. Old data will be overwritten.
                // Its expected that there is no host interaction
                ",
            },
            { 
                :name => "DRAM_NO_PTR_UPDATE_ON_PHASE_END", :offset => "(DRAM_RESET_WR_PTR_TO_BASE_ON_FULL + DRAM_RESET_WR_PTR_TO_BASE_ON_FULL_WIDTH)", :width => "1",
                :description  => "\
                // The internal ncrisc rd/wr pointers will not be updated at phase end
                // Its expected that there is no host interaction
                ",
            },
            { 
                :name => "DRAM_WR_BUFFER_FLUSH_AND_RST_PTRS", :offset => "(DRAM_NO_PTR_UPDATE_ON_PHASE_END + DRAM_NO_PTR_UPDATE_ON_PHASE_END_WIDTH)", :width => "1",
                :description  => "\
                // Before ending the phase the ncrisc will wait until the host has emptied the write buffer and then reset the read and write pointers to base
                // This can be used for hosts that do not want to track wrapping
                // The host must be aware of this behaviour for this functionality to work
                ",
            },
            { :name => "NCRISC_LOOP_NEXT_PIC_INT_ON_PHASE", :offset => "0", :width => "20" },
        ],
    },

    {
        :index => 206,
        :name => "STREAM_MSG_BLOB_BUF_START",
        :description  => "\
        // Start address (in words) of the message blob buffer. 
        // Only used when out-of-order execution is enabled. Read value consists of this register + current message blob offset.
        ",
        :fields =>  [
        ],
    },
    {
        :index => 207,
        :name => "STREAM_GLOBAL_OFFSET_TABLE",
        :description  => "\
        // Global offset table write entry interface.
        ",
        :fields =>  [
            { :name => "GLOBAL_OFFSET_VAL", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "GLOBAL_OFFSET_TABLE_INDEX_SEL", :offset => "(GLOBAL_OFFSET_VAL+GLOBAL_OFFSET_VAL_WIDTH)", :width => "GLOBAL_OFFSET_TABLE_SIZE_WIDTH" },
            { :name => "GLOBAL_OFFSET_TABLE_CLEAR", :offset => "(GLOBAL_OFFSET_TABLE_INDEX_SEL+GLOBAL_OFFSET_TABLE_INDEX_SEL_WIDTH)", :width => "1" },
        ],
    },
    # Multi register parameters for autocfg
    {
        :index => 208,
        :name => "FIRMWARE_SCRATCH",
        :description  => "\
        // Scratch location for firmware usage
        // Guarantees that no side-effects occur in Overlay hardware
        // Does not map to any actual registers in streams
        ",
        :fields =>  [
        ],
    },
    # 209 to 223 are reserved for FIRMWARE_SCRATCH

    {
        :index => 224,
        :name => "STREAM_LOCAL_SRC_MASK",
        :description  => "\
        // Bit mask of connnected local source. Dont care if LOCAL_SOURCES_CONNECTED == 0.
        // Mask segments [23:0], [47:24], and [63:48] are at indexes STREAM_LOCAL_SRC_MASK_REG_INDEX, 
        // STREAM_LOCAL_SRC_MASK_REG_INDEX+1, STREAM_LOCAL_SRC_MASK_REG_INDEX+2. 
        ",
        :fields =>  [
        ],
    },
    # 225 to 253 are reserved for STREAM_LOCAL_SRC_MASK (incase we want more streams)

    {
        :index => 254,
        :name => "STREAM_MSG_HEADER_FETCH",
        :description  => "\
        // Reserved for msg header fetch interface
        ",
        :fields =>  [
        ],
    },
    {
        :index => 255,
        :name => "RESERVED1",
        :description  => "\
        // Reserved for legacy reasons. This range appears not to be used in rtl anymore.
        ",
        :fields =>  [
        ],
    },
    
    # Non autocfg registers
    {
        :index => 256,
        :name => "STREAM_SCRATCH32",
        :description  => "\
        // Only in receiver endpoint/dram streams
        // A 32 bit scratch register
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_WAIT_STATUS",
        :description  => "\
        // Status info for the stream.
        ",
        :fields =>  [
            { 
                :name => "WAIT_SW_PHASE_ADVANCE_SIGNAL", :offset => "0", :width => "1",
                :description  => "\
                // Set when stream is in START state with auto-config disabled, or if auto-config is enabled
                // but PHASE_AUTO_ADVANCE=0 
                ",
            },
            { 
                :name => "WAIT_PREV_PHASE_DATA_FLUSH", :offset => "(WAIT_SW_PHASE_ADVANCE_SIGNAL+WAIT_SW_PHASE_ADVANCE_SIGNAL_WIDTH)", :width => "1",
                :description  => "\
                // Set when stream has configured the current phase, but waits data from the previous one to be flushed.
                ",
            },
            { 
                :name => "MSG_FWD_ONGOING", :offset => "(WAIT_PREV_PHASE_DATA_FLUSH+WAIT_PREV_PHASE_DATA_FLUSH_WIDTH)", :width => "1",
                :description  => "\
                // Set when stream is in data forwarding state. 
                ",
            },
            { :name => "STREAM_CURR_STATE", :offset => "(MSG_FWD_ONGOING+MSG_FWD_ONGOING_WIDTH)", :width => "4" },
            { :name => "TOKEN_GOTTEN", :offset => "(STREAM_CURR_STATE+STREAM_CURR_STATE_WIDTH)", :width => "1" },
            { :name => "INFINITE_PHASE_END_DETECTED", :offset => "(TOKEN_GOTTEN+TOKEN_GOTTEN_WIDTH)", :width => "1" },
            { :name => "INFINITE_PHASE_END_HEADER_BUFFER_DETECTED", :offset => "(INFINITE_PHASE_END_DETECTED+INFINITE_PHASE_END_DETECTED_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NUM_MSGS_RECEIVED_IN_BUF_AND_MEM",
        :description  => "\
        // Only in receiver endpoint streams (stream 4 and 5)
        // Read-only. Tells you the number of tiles that have arrived in L1
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NUM_MSGS_RECEIVED",
        :description  => "\
        // Number of received & stored messages (read-only). 
        // To get the total number of messages penidng in memory read 
        // STREAM_NUM_MSGS_RECEIVED_IN_BUF_AND_MEM_REG_INDEX
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_BUF_SPACE_AVAILABLE",
        :description  => "\
        // Available buffer space at the stream (in 16B words). 
        // Source cant send data unless available space > 0.  
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_BUF_SPACE_AVAILABLE",
        :description  => "\
        // Available msg info buffer space at the stream (in 16B words). 
        // Source cant send data unless available space > 0.  
        // Only valid when MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NEXT_RECEIVED_MSG_ADDR",
        :description  => "\
        // Memory address (in words) of the next in line received message (read-only). 
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_NEXT_RECEIVED_MSG_SIZE",
        :description  => "\
        // Size in words of the next in line received message (read-only). 
        ",
        :fields =>  [
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_MULTI_MSG_CLEAR",
        :description  => "\
        // Clear message info, move read pointer, and reclaim buffer space for one or more stored messages.
        // This is a special case of STREAM_MSG_INFO_CLEAR/STREAM_MSG_DATA_CLEAR where we arent streaming data
        // and instead we just want to clear a bunch of messages after we have used them.
        // If you are using streaming it is better to use STREAM_MSG_INFO_CLEAR/STREAM_MSG_DATA_CLEAR instead.
        // You should not use both STREAM_MSG_INFO_CLEAR/STREAM_MSG_DATA_CLEAR and STREAM_MULTI_MSG_CLEAR at the same time
        // Must be used only for streams where RECEIVER_ENDPOINT == 1.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_CLEAR",
        :description  => "\
        // Clear message info for one or more stored messages.  Only valid values are 1, 2, or 4. 
        // No effect on the read pointer. 
        // Should be used only for streams where RECEIVER_ENDPOINT == 1.  
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_DATA_CLEAR",
        :description  => "\
        // Move read pointer & reclaim buffer space for one or more stored messages.  
        // Sends flow control update to the source if REMOTE_SOURCE==1. 
        // Only valid values are 1, 2, or 4. 
        // Should be used only for streams where RECEIVER_ENDPOINT == 1, after 
        // STREAM_MSG_INFO_CLEAR_REG has been written with the same value. 
        ",
        :fields =>  [
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_ADVANCE",
        :description  => "\
        // Write-only. Write 1 to advance to the next phase if PHASE_AUTO_ADVANCE == 0.
        ",
        :fields =>  [
        ],
    },
    
    {
        :index => :prev_plus_1,
        :name => "STREAM_DEST_PHASE_READY_UPDATE",
        :description  => "\
        // Write phase number to indicate destination ready for the given phase. 
        // (This is done automatically by stream hardware when starting a phase with REMOTE_SOURCE=1.)
        // The phase number is the one indicated by STREAM_REMOTE_SRC_PHASE_REG at destination. 
        // This register is mapped to the shared destination ready table, not a per-stream register.
        // (Stream index is taken from the register address, and stored into the table along with the
        // phase number.)
        ",
        :fields =>  [
            { :name => "PHASE_READY_DEST_NUM", :offset => "0", :width => "6" },
            { :name => "PHASE_READY_NUM", :offset => "(PHASE_READY_DEST_NUM+PHASE_READY_DEST_NUM_WIDTH)", :width => "20" },
            { 
                :name => "PHASE_READY_MCAST", :offset => "(PHASE_READY_NUM+PHASE_READY_NUM_WIDTH)", :width => "1",
                :description  => "\
                // set if this stream is part of multicast group (i.e. if REMOTE_SRC_IS_MCAST==1)
                ",
            },
            { 
                :name => "PHASE_READY_TWO_WAY_RESP", :offset => "(PHASE_READY_MCAST+PHASE_READY_MCAST_WIDTH)", :width => "1",
                :description  => "\
                // set if the message is in response to 2-way handshake 
                ",
            },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_SRC_READY_UPDATE",
        :description  => "\
        // Source ready message register for two-way handshake (sent by source in 
        // case destination ready entry is not found in the table). 
        // If received by a stream that already sent its ready update, it prompts resending.
        ",
        :fields =>  [
            { :name => "STREAM_REMOTE_RDY_SRC_X", :offset => "0", :width => "NOC_ID_WIDTH" },
            { :name => "STREAM_REMOTE_RDY_SRC_Y", :offset => "(STREAM_REMOTE_RDY_SRC_X+STREAM_REMOTE_RDY_SRC_X_WIDTH)", :width => "NOC_ID_WIDTH" },
            { :name => "REMOTE_RDY_SRC_STREAM_ID", :offset => "(STREAM_REMOTE_RDY_SRC_Y+STREAM_REMOTE_RDY_SRC_Y_WIDTH)", :width => "STREAM_ID_WIDTH" },
            { :name => "IS_TOKEN_UPDATE", :offset => "(REMOTE_RDY_SRC_STREAM_ID+REMOTE_RDY_SRC_STREAM_ID_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE",
        :description  => "\
        // Update available buffer space at remote destination stream. 
        // this is rd_ptr increment issued when a message is forwarded
        ",
        :fields =>  [
            { :name => "REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE_DEST_NUM", :offset => "0", :width => "6" },
            { :name => "REMOTE_DEST_BUF_WORDS_FREE_INC", :offset => "(REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE_DEST_NUM+REMOTE_DEST_BUF_SPACE_AVAILABLE_UPDATE_DEST_NUM_WIDTH)", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "REMOTE_DEST_MSG_INFO_BUF_WORDS_FREE_INC", :offset => "(REMOTE_DEST_BUF_WORDS_FREE_INC+REMOTE_DEST_BUF_WORDS_FREE_INC_WIDTH)", :width => "MSG_INFO_BUF_SIZE_WORDS_WIDTH" },
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_RESET",
        :description  => "\
        // Write to reset & stop stream. 
        ",
        :fields =>  [
        ],
    },

    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_GROUP_ZERO_MASK_AND",
        :description  => "\
        // AND value of zero masks for the pending message group. 
        // (Header bits [95:64].)
        // Read-only.  Valid only for receiver endpoint streams.  
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_FULL",
        :description  => "\
        // Returns 1 if the message info register is full (read-only). 
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_FULLY_LOADED",
        :description  => "\
        // Returns 1 if the message info register is full (read-only), and there are no outstanding loads in progress. 
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_INFO_CAN_PUSH_NEW_MSG",
        :description  => "\
        // Returns 1 if the message info register can accept new message push (read-only). 
        // Equivalent to checking the condition:
        //   (STREAM_MSG_INFO_FULL_REG_INDEX == 0) && (STREAM_MSG_INFO_PTR_REG_INDEX == STREAM_MSG_INFO_WR_PTR_REG_INDEX)
        // (I.e. ther is free space in the msg info register, and we dont have any message info headers in the
        //  memory buffer about to be fetched.)
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_MSG_GROUP_COMPRESS",
        :description  => "\
        // Concat compress flags from 4 tiles in the pending message group.
        // (Header bit 52.)
        // Read-only.  Valid only for receiver endpoint streams. 
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_PHASE_ALL_MSGS_PUSHED",
        :description  => "\
        // Returns 1 if all msgs that the phase can accept have been pushed into the stream. 0 otherwise.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_READY_FOR_MSG_PUSH",
        :description  => "\
        // Returns 1 if the stream is in a state where it can accept msgs.
        ",
        :fields =>  [
        ],
    },
    {
        :index => :prev_plus_1,
        :name => "STREAM_GLOBAL_OFFSET_TABLE_RD",
        :description  => "\
				// Returns global offset table entry 0. The rest of the table entries can be read at index
        // STREAM_GLOBAL_OFFSET_TABLE_RD_REG_INDEX+i, up to maximum entry size.
        ",
        :fields =>  [
        ],
    },

    # Multi register parameters for autocfg
    {
        :index => 288,
        :name => "STREAM_BLOB_AUTO_CFG_DONE",
        :description  => "\
        // 32 bit register. Each bit denotes whether the corresponding stream has completed its blob run and is in idle state.
        // Resets to 0 upon starting a new stream run. Initially all are 0 to exclude streams that might not be used.
        // Can be manually reset to 0 by writing 1 to the corresponding bit.
        // Exists only in stream 0
        ",
        :fields =>  [
        ],
    },
    # 289 is reserved for STREAM_BLOB_AUTO_CFG_DONE
    {
        :index => 290,
        :name => "STREAM_BLOB_NEXT_AUTO_CFG_DONE",
        :description  => "\
        // Reading this register will give you a stream id of a stream that finished its blob (according to STREAM_BLOB_AUTO_CFG_DONE_REG_INDEX)
        // Subsequent reads will give you the next stream, untill all streams are read, after which it will loop
        // This register is only valid if BLOB_NEXT_AUTO_CFG_DONE_VALID is set (i.e. if STREAM_BLOB_AUTO_CFG_DONE_REG_INDEX non-zero)
        // Exists only in stream 0
        ",
        :fields =>  [
            { :name => "BLOB_NEXT_AUTO_CFG_DONE_STREAM_ID", :offset => "0", :width => "STREAM_ID_WIDTH" },
            { :name => "BLOB_NEXT_AUTO_CFG_DONE_VALID", :offset => "16", :width => "1" },
        ],
    },

    {
        :index => 291,
        :name => "STREAM_RECEIVER_ENDPOINT_SET_MSG_HEADER",
        :description  => "\
        // For receiver endpoint streams that expose the full message header bus to unpacker,
        // write this register to specify the full header in case the stream is not snooping
        // a remote source but instead also works as a source endpoint. 
        // Write (STREAM_RECEIVER_ENDPOINT_SET_MSG_HEADER_REG_INDEX+i) to set bits [i*32 +: 32]
        // of the message header for the next message, prior to writing STREAM_SOURCE_ENDPOINT_NEW_MSG_INFO_REG_INDEX. 
        ",
        :fields =>  [
        ],
    },
    # 292 to 296 are reserved for STREAM_RECEIVER_ENDPOINT_SET_MSG_HEADER

    {
        :index => 297,
        :name => "STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE",
        :description  => "\
        // Available buffer space at remote destination stream(s) for both the data buffer and msg info buffer. 
        // Dont care unless REMOTE_RECEIVER == 1. 
        // Source cant send data unless WORDS_FREE > 0.  
        // Read-only; updated automatically to maximum value when 
        // STREAM_REMOTE_DEST_BUF_SIZE_REG/STREAM_REMOTE_DEST_MSG_INFO_BUF_SIZE_REG is updated. 
        // For multicast streams, values for successive destinations are at 
        // subsequent indexes (STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_REG_INDEX+1, 
        // STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE_REG_INDEX+2, etc.).
        // REMOTE_DEST_MSG_INFO_WORDS_FREE is only valid when DEST_MSG_INFO_BUF_FLOW_CTRL is true
        ",
        :fields =>  [
            { :name => "REMOTE_DEST_WORDS_FREE", :offset => "0", :width => "MEM_WORD_ADDR_WIDTH" },
            { :name => "REMOTE_DEST_MSG_INFO_WORDS_FREE", :offset => "(REMOTE_DEST_WORDS_FREE+REMOTE_DEST_WORDS_FREE_WIDTH)", :width => "MSG_INFO_BUF_SIZE_WORDS_WIDTH" },
        ],
    },
    # 298 to 328 are reserved for STREAM_REMOTE_DEST_BUF_SPACE_AVAILABLE

    {
        :index => 329,
        :name => "STREAM_RECEIVER_MSG_INFO",
        :description  => "\
        // Read-only register view of the bits on the o_full_msg_info bus. 
        // Exposed as 32-bit read-only registers starting at this index. 
        ",
        :fields =>  [
        ],
    },
    # 330 to 498 is reserved for STREAM_RECEIVER_MSG_INFO
    
    {
        :index => 499,
        :name => "STREAM_DEBUG_STATUS_SEL",
        :description  => "\
        // Debug bus stream selection. Write the stream id for the stream that you want exposed on the debug bus
        // This register only exists in stream 0.
        ",
        :fields =>  [
            { :name => "DEBUG_STATUS_STREAM_ID_SEL", :offset => "0", :width => "STREAM_ID_WIDTH" },
            { :name => "DISABLE_DEST_READY_TABLE", :offset => "(DEBUG_STATUS_STREAM_ID_SEL+DEBUG_STATUS_STREAM_ID_SEL_WIDTH)", :width => "1" },
            { :name => "DISABLE_GLOBAL_OFFSET_TABLE", :offset => "(DISABLE_DEST_READY_TABLE+DISABLE_DEST_READY_TABLE_WIDTH)", :width => "1" },
        ],
    },
    {
        :index => 500,
        :name => "STREAM_DEBUG_ASSERTIONS",
        :description  => "\
        // Debugging: Non-zero value indicates an invalid stream operation occured.
        // Sticky, write 1 to clear.
        ",
        :fields =>  [
        ],
    },
    {
        :index => 501,
        :name => "STREAM_DEBUG_STATUS",
        :description  => "\
        // Read-only register that exposes internal states of the stream.
        // Useful for debugging. Valid 32-bit data from STREAM_DEBUG_STATUS_REG_INDEX + 0 to STREAM_DEBUG_STATUS_REG_INDEX + 9
        ",
        :fields =>  [
        ],
    },
    {
        :index => 511,
        :name => "RESERVED2",
        :description  => "\
        // Reserved for legacy reasons. This range appears not to be used in rtl anymore.
        ",
        :fields =>  [
        ],
    },
]

def noc_bit_width_of_int(num)
   width_of_int = 0

   if (num == 0)
      width_of_int = 1
   else
      width_of_int = 0
      while (num != 0) do
         width_of_int = width_of_int + 1
         num = num >> 1
      end
   end

   return width_of_int
end

c_header_basic = "\
#ifndef NOC_OVERLAY_PARAMETERS_BASIC_H
#define NOC_OVERLAY_PARAMETERS_BASIC_H

#define NOC_NUM_STREAMS 64
#define ETH_NOC_NUM_STREAMS 32

#define NUM_MCAST_STREAM_ID_START 0
#define NUM_MCAST_STREAM_ID_END   3
#define NUM_RECEIVER_ENDPOINT_STREAM_ID_START 4
#define NUM_RECEIVER_ENDPOINT_STREAM_ID_END   5
#define NUM_REMOTE_RECEIVER_STREAM_ID_START 0
#define NUM_REMOTE_RECEIVER_STREAM_ID_END 63
#define RECEIVER_ENDPOINT_STREAM_MSG_GROUP_SIZE 4
#define RECEIVER_ENDPOINT_STREAM_MSG_INFO_FIFO_GROUPS     4
#define NON_RECEIVER_ENDPOINT_STREAM_MSG_INFO_FIFO_GROUPS 2
#define DEST_READY_COMMON_CACHE_NUM_ENTRIES 24
#define DEST_READY_MCAST_CACHE_NUM_ENTRIES 8

#define NOC_OVERLAY_START_ADDR     0xFFB40000
#define NOC_STREAM_REG_SPACE_SIZE  0x1000

#define STREAM_REG_ADDR(stream_id, reg_id) ((NOC_OVERLAY_START_ADDR) + (((uint32_t)(stream_id))*(NOC_STREAM_REG_SPACE_SIZE)) + (((uint32_t)(reg_id)) << 2))

#define NUM_NOCS                   2
#define NOC0_REGS_START_ADDR       0xFFB20000
#define NOC1_REGS_START_ADDR       0xFFB30000

#define NCRISC_STREAM_RANGE_1_START 0
#define NCRISC_STREAM_RANGE_1_END   3
#define NCRISC_STREAM_RANGE_2_START 8
#define NCRISC_STREAM_RANGE_2_END   11
#define NCRISC_PIC_CONFIG_PHASE_DEFAULT           0

#ifdef TB_NOC

extern \"C\" {
#include \"noc.h\"
#include \"noc_api_dpi.h\"
}

#else

#define NOC_STREAM_WRITE_REG(stream_id, reg_id, val)  ((*((volatile uint32_t*)(STREAM_REG_ADDR(stream_id, reg_id)))) = (val))
#define NOC_STREAM_READ_REG(stream_id, reg_id)        (*((volatile uint32_t*)(STREAM_REG_ADDR(stream_id, reg_id))))

#define NOC_STREAM_WRITE_REG_FIELD(stream_id, reg_id, field, val) (NOC_STREAM_WRITE_REG(stream_id, reg_id, ((NOC_STREAM_READ_REG(stream_id, reg_id) & ~((1 << field##_WIDTH) - 1)) | ((val & ((1 << field##_WIDTH) - 1)) << field))))
#define NOC_STREAM_READ_REG_FIELD(stream_id, reg_id, field)       ((NOC_STREAM_READ_REG(stream_id, reg_id) >> field) & ((1 << field##_WIDTH) - 1))

#define NOC_WRITE_REG(addr, val) ((*((volatile uint32_t*)(addr)))) = (val)
#define NOC_READ_REG(addr)       (*((volatile uint32_t*)(addr)))

#endif


#define NOC_ID_WIDTH     6
#define STREAM_ID_WIDTH  6

#define DEST_CNT_WIDTH   6
#define NOC_NUM_WIDTH     1

#define STREAM_REG_INDEX_WIDTH 9
#define STREAM_REG_CFG_DATA_WIDTH 24

#define MEM_WORD_WIDTH 16
#define MEM_WORD_ADDR_WIDTH 17

#define MEM_WORD_BIT_OFFSET_WIDTH 7

#define MSG_INFO_BUF_SIZE_WORDS #{msg_info_buf_size_words}
#define MSG_INFO_BUF_SIZE_BITS  #{noc_bit_width_of_int(msg_info_buf_size_words-1)}
#define MSG_INFO_BUF_SIZE_POW_BITS #{noc_bit_width_of_int(noc_bit_width_of_int(msg_info_buf_size_words-1)-1)}
#define MSG_INFO_BUF_SIZE_WORDS_WIDTH (MSG_INFO_BUF_SIZE_BITS + 1)

#define GLOBAL_OFFSET_TABLE_SIZE #{global_offset_table_size}
#define GLOBAL_OFFSET_TABLE_SIZE_WIDTH #{noc_bit_width_of_int(global_offset_table_size-1)}

#endif
"

svh_header_basic = "\
////
parameter OVERLAY_INST_ID = 0;
////
parameter NUM_NOCS = 2;
parameter NOC_OVERLAY_NUM_STREAMS = (OVERLAY_INST_ID == 1) ? 32 : 64;
parameter NOC_OVERLAY_STREAM_GROUPS = 8;
localparam NOC_OVERLAY_STREAMS_PER_GROUP = NOC_OVERLAY_NUM_STREAMS/NOC_OVERLAY_STREAM_GROUPS;
////
parameter NOC_OVERLAY_NUM_MCAST_STREAMS = (OVERLAY_INST_ID == 1) ? 2 : 4;
parameter NOC_OVERLAY_NUM_REMOTE_SOURCE_STREAMS = NOC_OVERLAY_NUM_STREAMS;
parameter NOC_OVERLAY_MAX_MCAST_DESTS = 32;
parameter STREAM_ID_WIDTH = 6;
////
parameter NOC_NIU_REGS_START_ADDR = 'hFFB2_0000;
parameter NIU_REG_SPACE_SIZE = 'h10000;
parameter NOC_OVERLAY_REGS_START_ADDR = 'hFFB4_0000;
parameter STREAM_REG_SPACE_SIZE = 'h1000;
parameter STREAM_DEST_CNT_WIDTH = 6;
parameter DEST_READY_TABLE_SIZE = 32;
parameter DEST_READY_TABLE_MAX_UNICAST = 24;
parameter DEST_ADDR_WIDTH = 32;
parameter GLOBAL_OFFSET_TABLE_SIZE = #{global_offset_table_size};
localparam GLOBAL_OFFSET_TABLE_SIZE_WIDTH = noc_bit_width_of_int(GLOBAL_OFFSET_TABLE_SIZE-1);
////
parameter NUM_RECEIVER_ENDPOINT_STREAMS = (OVERLAY_INST_ID == 1) ? 0 : 2;
localparam NOC_OVERLAY_NUM_GATHER_STREAMS = NOC_OVERLAY_NUM_MCAST_STREAMS + NUM_RECEIVER_ENDPOINT_STREAMS;
localparam NOC_OVERLAY_GATHER_STREAM_INDEX = noc_bit_width_of_int(NOC_OVERLAY_NUM_GATHER_STREAMS-1);
parameter LOCAL_SRC_MSG_INFO_FIFO_DEPTH = 2;
////
parameter RECEIVER_ENDPOINT_STREAM_MSG_GROUP_SIZE = 4;
parameter RECEIVER_ENDPOINT_STREAM_MSG_INFO_FIFO_GROUPS = 4;
parameter MSG_ARB_GROUP_SIZE_WIDTH = 3;  
parameter STREAM_DEBUG_STATUS_REG_WIDTH = 320;
parameter STREAM_DEBUG_ASSERTIONS_REG_WIDTH = 5;
parameter NUM_IRQ_STREAM_SCRATCH_REGS = 6;
////
parameter NUM_DRAM_ENDPOINT_STREAMS = 8;
parameter DRAM_ENDPOINT_STREAM_MSG_GROUP_SIZE = 2;
parameter DRAM_ENDPOINT_STREAM_MSG_INFO_FIFO_GROUPS = (OVERLAY_INST_ID == 1) ? 16 : 16;
parameter DRAM_NCRISC_EN_PHASE_START_BIT = 0;
parameter DRAM_NCRISC_EN_PHASE_END_BIT = 1;
parameter DRAM_WRITE_NCRISC_BIT = 2;
////
parameter PHASE_ID_WIDTH = 20;
parameter PHASE_INCR_WIDTH = 12;
////
parameter  MEM_SIZE_WORDS = 'h20000;
parameter  PHASE_MSG_CNT_WIDTH = 12;
localparam MEM_BYTE_ADDR_WIDTH = noc_bit_width_of_int(MEM_SIZE_WORDS*MEM_DATA_WIDTH/8-1);
localparam MEM_WORD_ADDR_WIDTH = noc_bit_width_of_int(MEM_SIZE_WORDS-1);
localparam NEW_MSG_INFO_REG_MSG_SIZE_WIDTH = REG_DATA_WIDTH - MEM_WORD_ADDR_WIDTH - 1;
////
parameter MSG_INFO_BUF_SIZE_WORDS = 'h#{msg_info_buf_size_words};
localparam MSG_INFO_BUF_SIZE_BITS = 'h#{noc_bit_width_of_int(msg_info_buf_size_words-1)};
localparam MSG_INFO_BUF_SIZE_POW_BITS = 'h#{noc_bit_width_of_int(noc_bit_width_of_int(msg_info_buf_size_words-1)-1)};
localparam MSG_INFO_BUF_SIZE_WORDS_WIDTH = (MSG_INFO_BUF_SIZE_BITS + 'h1);
////
parameter STREAM_REG_NUM = 512;
parameter STREAM_REG_AUTO_CFG_WIDTH = 8; // Only first 256 registers can be programmed through autocfg
localparam STREAM_REG_INDEX_WIDTH = noc_bit_width_of_int(STREAM_REG_NUM-1);
////
localparam WORDS_PER_NOC_PAYLOAD = NOC_PAYLOAD_WIDTH/MEM_DATA_WIDTH;
parameter  DEFAULT_PARTIAL_MSG_WORDS_SEND_THRESHOLD = 16;
////
parameter  NOC2STREAM_MSG_BLOB_FETCH_ADDR_BIT = 9;
parameter  NOC2STREAM_MSG_HEADER_FETCH_ADDR_BIT = 10;
parameter  NOC2STREAM_AUTO_CFG_ADDR_BIT   = 11;
////
parameter  BUF_SPACE_AVAILABLE_ACK_THRESHOLD_WIDTH = 4;
////
parameter NOC_OVERLAY_REQ_FLIT_FIFO_DEPTH = 2;
parameter NOC_OVERLAY_DATA_SEND_ACK_FIFO_DEPTH = 6;
////
parameter DEFAULT_REG_UPDATE_REQ_IF = 1;
parameter DEFAULT_UNICAST_REQ_IF = 0;
////
localparam AUTO_CONFIG_REQ_WIDTH = (MEM_BYTE_ADDR_WIDTH + STREAM_REG_AUTO_CFG_WIDTH + 1 + 1);
localparam REMOTE_UPDATE_REQ_WIDTH = (4*NOC_ID_WIDTH + 3 + STREAM_ID_WIDTH + STREAM_REG_INDEX_WIDTH + REG_DATA_WIDTH);
localparam DATA_FWD_REQ_WIDTH = (4*NOC_ID_WIDTH + STREAM_ID_WIDTH + 2*MEM_WORD_ADDR_WIDTH + 2*DEST_ADDR_WIDTH + NOC_PACKET_ARB_PRIORITY_WIDTH + 6);
localparam ETH_REMOTE_UPDATE_REQ_WIDTH = (STREAM_ID_WIDTH + STREAM_REG_INDEX_WIDTH + REG_DATA_WIDTH);
localparam ETH_DATA_FWD_REQ_WIDTH = (STREAM_ID_WIDTH + 4*MEM_WORD_ADDR_WIDTH + 2);
////
"

rb_header_basic = "\

MSG_INFO_BUF_SIZE_WORDS          = #{msg_info_buf_size_words}
MSG_INFO_BUF_SIZE_BITS           = #{noc_bit_width_of_int(msg_info_buf_size_words-1)}
MSG_INFO_BUF_SIZE_POW_BITS       = #{noc_bit_width_of_int(noc_bit_width_of_int(msg_info_buf_size_words-1)-1)}
MSG_INFO_BUF_SIZE_WORDS_WIDTH    = (MSG_INFO_BUF_SIZE_BITS + 1)
GLOBAL_OFFSET_TABLE_SIZE         = #{global_offset_table_size}
GLOBAL_OFFSET_TABLE_SIZE_WIDTH   = #{noc_bit_width_of_int(global_offset_table_size-1)}

STREAM_ID_WIDTH                  = 6
NOC_NUM_STREAMS                  = 64
NOC_ID_WIDTH                     = 6
NOC_NUM_WIDTH                    = 1
NOC_ADDR_LOCAL_WIDTH             = 36
STREAM_REG_INDEX_WIDTH           = 9
STREAM_REG_CFG_DATA_WIDTH        = 24
MEM_WORD_BYTES                   = 16
MEM_WORD_ADDR_WIDTH              = 17
MEM_WORD_BIT_OFFSET_WIDTH        = 7
MAX_TILES_MSG_INFO_BUF_PER_PHASE = 2048
"

prev_register = nil
registers.each do |register|
    # Process :prev_plus_1 and :same_as_prev
    if register[:index] == :prev_plus_1
        register[:index] = prev_register[:index] + 1
    end
    if register[:index] == :same_as_prev
        register[:index] = prev_register[:index]
    end

    # Add :width_name to fields
    register[:fields].each do |field|
        field[:width_name] = field[:name] + "_WIDTH"
    end

    # Make fields printing pretty (align columns)
    max_len = nil
    register[:fields].each do |field|
        # :width_name will always be larger than :fields, so we dont need to check :fields
        if max_len == nil || max_len < field[:width_name].length
            max_len = field[:width_name].length
        end
    end
    
    register[:fields].each do |field|
        field[:name] = field[:name].ljust(max_len)
        field[:width_name] = field[:width_name].ljust(max_len)
    end

    # Remove whitespace after newline and last newline in :description
    register[:description] = register[:description].strip
    register[:description] = register[:description].gsub(/\n\s+/, "\n")
    if register[:description] != ""
        register[:description] = register[:description] + "\n"
    end

    register[:fields].each do |field|
        if field[:description]
            field[:description] = field[:description].strip
            field[:description] = field[:description].gsub(/\n\s+/, "\n")
        else
            field[:description] = ""
        end

        if field[:description] != ""
            field[:description] = field[:description] + "\n"
        end
    end

    prev_register = register
end

-%>
<%- if type == :c_header -%>
<%= header -%>

#ifndef NOC_OVERLAY_PARAMETERS_H
#define NOC_OVERLAY_PARAMETERS_H

<%= c_header_basic -%>

<%- registers.each do |register| -%>
<%= register[:description] -%>
#define   <%= register[:name].upcase %>_REG_INDEX   <%= register[:index] %>
<%- register[:fields].each do |field| -%>
<%= field[:description] -%>
#define       <%= field[:name].upcase %> <%= field[:offset] %>
#define       <%= field[:width_name].upcase %>   <%= field[:width] %>
<%- end -%>

<%- end -%>
#endif // def NOC_OVERLAY_PARAMETERS_H

<%- elsif type == :cpp_header -%>
<%= header -%>

#pragma once

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>
#include <stdexcept>

<%= c_header_basic -%>

namespace Noc {

typedef struct OverlayField_ {
    std::string name;
    std::uint32_t offset;
    std::uint32_t width;
    std::string description;
} OverlayField;

typedef struct OverlayReg_ {
    std::string name;
    std::uint32_t index;
    std::unordered_map<std::string, std::uint32_t> fields_by_name;
    std::unordered_map<std::uint32_t, std::uint32_t> fields_by_offset;
    std::vector<OverlayField> fields;
    std::string description;
} OverlayReg;

// OverLayParams
class OLP {
    private:
        static const std::unordered_map<std::string, std::uint32_t> registers_by_name;
        static const std::unordered_map<std::uint32_t, std::uint32_t> registers_by_index;
        static const std::vector<OverlayReg> registers;
        static const std::unordered_map<std::string, std::uint32_t> fields_by_name;
        static const std::vector<OverlayField> fields;

    private:
        // Disallow creating an instance of this object
        OLP() {}

    public:
        static bool HasReg(std::string label) 
        {
            return registers_by_name.count(label) >= 1;
        }

        // There might be multiple registers with the same index
        // If so a register you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static bool HasReg(std::uint32_t index)
        {
            return registers_by_index.count(index) >= 1;
        }

        static const std::vector<OverlayReg>& GetAllRegs()
        {
            return registers;
        }

        // There might be multiple registers with the same index
        // If so a register you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static std::string RegName(std::uint32_t index) 
        {
            if (HasReg(index))
                return registers[registers_by_index.at(index)].name;
            else
                throw std::runtime_error("Non-existant overlay register index: " + std::to_string(index));
        }

        static std::uint32_t RegIdx(std::string label) 
        {
            if (HasReg(label))
                return registers[registers_by_name.at(label)].index;
            else
                throw std::runtime_error("Non-existant overlay register: " + std::string(label));
        }

        static std::string RegInfo(std::string label) 
        {
            if (HasReg(label))
                return registers[registers_by_name.at(label)].description;
            else
                throw std::runtime_error("Non-existant overlay register: " + std::string(label));
        }

        ////////////////////////////////////

        static bool HasFld(std::string label) 
        {
            return fields_by_name.count(label) >= 1;
        }

        static const std::vector<OverlayField>& GetAllFlds()
        {
            return fields;
        }

        static std::uint32_t FldOff(std::string label) 
        {
            if (HasFld(label))
                return fields[fields_by_name.at(label)].offset;
            else
                throw std::runtime_error("Non-existant overlay field: " + std::string(label));
        }

        static std::uint32_t FldW(std::string label) 
        {
            if (HasFld(label))
                return fields[fields_by_name.at(label)].width;
            else
                throw std::runtime_error("Non-existant overlay field: " + std::string(label));
        }

        static std::string FldInfo(std::string label) 
        {
            if (HasFld(label))
                return fields[fields_by_name.at(label)].description;
            else
                throw std::runtime_error("Non-existant overlay field: " + std::string(label));
        }

        ////////////////////////////////////

        static bool HasFld(std::string reg_label, std::string field_label) 
        {
            return HasReg(reg_label) && 
                   (registers[registers_by_name.at(reg_label)].fields_by_name.count(field_label) >= 1);
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static bool HasFld(std::uint32_t reg_index, std::uint32_t field_offset) 
        {
            return HasReg(reg_index) && 
                   (registers[registers_by_index.at(reg_index)].fields_by_offset.count(field_offset) >= 1);
        }

        static const std::vector<OverlayField>& GetAllFlds(std::string reg_label)
        {
            if (HasReg(reg_label)) {
                return registers[registers_by_name.at(reg_label)].fields;
            } else {
                throw std::runtime_error("Non-existant overlay register: " + std::string(reg_label));
            }
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static const std::vector<OverlayField>& GetAllFlds(std::uint32_t reg_index)
        {
            if (HasReg(reg_index)) {
                return registers[registers_by_index.at(reg_index)].fields;
            } else {
                throw std::runtime_error("Non-existant overlay register index: " + std::to_string(reg_index));
            }
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static std::string FldName(std::uint32_t reg_index, std::uint32_t field_offset) 
        {
            if (HasFld(reg_index, field_offset)) {
                auto field_tmp = registers[registers_by_index.at(reg_index)].fields;
                auto index_field_temp = registers[registers_by_index.at(reg_index)].fields_by_offset.at(field_offset);
                return field_tmp[index_field_temp].name;
            } else {
                throw std::runtime_error("Non-existant overlay register field (index, offset): " + std::to_string(reg_index) + ", " + std::to_string(field_offset));
            }
        }

        static std::uint32_t FldOff(std::string reg_label, std::string field_label) 
        {
            if (HasFld(reg_label, field_label)) {
                auto field_tmp = registers[registers_by_name.at(reg_label)].fields;
                auto index_field_temp = registers[registers_by_name.at(reg_label)].fields_by_name.at(field_label);
                return field_tmp[index_field_temp].offset;
            } else {
                throw std::runtime_error("Non-existant overlay register field: " + std::string(reg_label) + ", " + std::string(field_label));
            }
        }

        static std::uint32_t FldW(std::string reg_label, std::string field_label) 
        {
            if (HasFld(reg_label, field_label)) {
                auto field_tmp = registers[registers_by_name.at(reg_label)].fields;
                auto index_field_temp = registers[registers_by_name.at(reg_label)].fields_by_name.at(field_label);
                return field_tmp[index_field_temp].width;
            } else {
                throw std::runtime_error("Non-existant overlay register field: " + std::string(reg_label) + ", " + std::string(field_label));
            }
        }

        // There might be multiple registers(fields) with the same index(offset)
        // If so a register(field) you didnt intend to access might be accessed.
        // Use accessor based on label if possible
        static std::uint32_t FldW(std::uint32_t reg_index, std::uint32_t field_offset) 
        {
            if (HasFld(reg_index, field_offset)) {
                auto field_tmp = registers[registers_by_index.at(reg_index)].fields;
                auto index_field_temp = registers[registers_by_index.at(reg_index)].fields_by_offset.at(field_offset);
                return field_tmp[index_field_temp].width;
            } else {
                throw std::runtime_error("Non-existant overlay register field (index, offset): " + std::to_string(reg_index) + ", " + std::to_string(field_offset));
            }
        }

        static std::string FldInfo(std::string reg_label, std::string field_label) 
        {
            if (HasFld(reg_label, field_label)) {
                auto field_tmp = registers[registers_by_name.at(reg_label)].fields;
                auto index_field_temp = registers[registers_by_name.at(reg_label)].fields_by_name.at(field_label);
                return field_tmp[index_field_temp].description;
            } else {
                throw std::runtime_error("Non-existant overlay register field: " + std::string(reg_label) + ", " + std::string(field_label));
            }
        }

};

const std::vector<OverlayReg> OLP::registers = {
<%- first_line_placed_outer = false -%>
<%- registers.each_with_index do |register, index| -%>
    <% if first_line_placed_outer -%>,<%- end -%>{
        "<%= register[:name].upcase.strip %>",
        <%= register[:index] %>,
        {
<%- first_line_placed = false -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
            <% if first_line_placed -%>,<%- end -%>{"<%= field[:name].upcase.strip %>", <%= field_index %>}
<%- first_line_placed = true -%>
<%- end -%>
<%- if !first_line_placed %>            std::unordered_map<std::string, std::uint32_t>()<%- end %>
        },
        {
<%- index_exists = {} -%>
<%- first_line_placed = false -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
<%- if !index_exists[field[:offset]] -%>
            <% if first_line_placed -%>,<%- end -%>{<%= field[:offset] %>, <%= field_index %>}
<%- first_line_placed = true -%>
<%- index_exists[field[:offset]] = true -%>
<%- end -%>
<%- end -%>
<%- if !first_line_placed %>            std::unordered_map<std::uint32_t, std::uint32_t>()<%- end %>
        },
        {
<%- first_line_placed = false -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
            <% if first_line_placed -%>,<%- end -%>{
                "<%= field[:name].upcase.strip %>",
                <%= field[:offset] %>,
                <%= field[:width] %>,
                "<%= field[:description].gsub(/\n/, '\\n') %>"
            }
<%- first_line_placed = true -%>
<%- end -%>
<%- if !first_line_placed %>            std::vector<OverlayField>()<%- end %>
        },
        "<%= register[:description].gsub(/\n/, '\\n') %>"
    }
<%- first_line_placed_outer = true -%>
<%- end -%>
};

const std::unordered_map<std::string, std::uint32_t> OLP::registers_by_name = {
<%- first_line_placed = false -%>
<%- registers.each_with_index do |register, index| -%>
    <% if first_line_placed -%>,<%- end -%>{"<%= register[:name].upcase.strip %>", <%= index %>}
<%- first_line_placed = true -%>
<%- end -%>
};

const std::unordered_map<std::uint32_t, std::uint32_t> OLP::registers_by_index = {
<%- index_exists = {} -%>
<%- first_line_placed = false -%>
<%- registers.each_with_index do |register, index| -%>
<%- if !index_exists[register[:index]] -%>
    <% if first_line_placed -%>,<%- end -%>{<%= register[:index] %>, <%= index %>}
<%- first_line_placed = true -%>
<%- index_exists[register[:index]] = true -%>
<%- end -%>
<%- end -%>
};

const std::vector<OverlayField> OLP::fields = {
<%- first_line_placed = false -%>
<%- registers.each_with_index do |register, index| -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
    <% if first_line_placed -%>,<%- end -%>{
        "<%= field[:name].upcase.strip %>",
        <%= field[:offset] %>,
        <%= field[:width] %>,
        "<%= field[:description].gsub(/\n/, '\\n') %>"
    }
<%- first_line_placed = true -%>
<%- end -%>
<%- end -%>
};

const std::unordered_map<std::string, std::uint32_t> OLP::fields_by_name = {
<%- first_line_placed = false -%>
<%- unrolled_index = 0 -%>
<%- registers.each_with_index do |register, index| -%>
<%- register[:fields].each_with_index do |field, field_index| -%>
    <% if first_line_placed -%>,<%- end -%>{"<%= field[:name].upcase.strip %>", <%= unrolled_index %>}
<%- unrolled_index = unrolled_index + 1 -%>
<%- first_line_placed = true -%>
<%- end -%>
<%- end -%>
};

}

<%- elsif type == :svh_header -%>
<%= header -%>

<%= svh_header_basic -%>

<%- registers.each do |register| -%>
parameter <%= register[:name].upcase %>_REG_INDEX = <%= register[:index] %>;
<%- end -%>

////

`ifdef NOC_TB_SIM

function string noc_overlay_get_reg_name;

input [32-1:0] reg_index;

   case (reg_index)   
<%- registers.each do |register| -%>
     <%= register[:name].upcase %>_REG_INDEX: noc_overlay_get_reg_name = "<%= register[:name].upcase %>_REG_INDEX";
<%- end -%>
     default: noc_overlay_get_reg_name = "UNDEFINED";     
   endcase

endfunction

`endif

<%- elsif type == :sed -%>

<%- registers.each_with_index do |register, index| -%>
find . -type f | xargs grep -sl <%= register[:name].upcase.strip %>_REG_INDEX | xargs sed -i 's/\(^\|[^a-zA-Z_]\)<%= register[:name].upcase.strip %>_REG_INDEX\($\|[^a-zA-Z0-9_]\)/\1OLP::RegIdx("<%= register[:name].upcase.strip %>")\2/g'
<%- register[:fields].each_with_index do |field, field_index| -%>
find . -type f | xargs grep -sl <%= field[:name].upcase.strip %> | xargs sed -i 's/\(^\|[^a-zA-Z_]\)<%= field[:name].upcase.strip %>\($\|[^a-zA-Z0-9_]\)/\1OLP::FldOff("<%= field[:name].upcase.strip %>")\2/g'
find . -type f | xargs grep -sl <%= field[:width_name].upcase.strip %> | xargs sed -i 's/\(^\|[^a-zA-Z_]\)<%= field[:width_name].upcase.strip %>\($\|[^a-zA-Z0-9_]\)/\1OLP::FldW("<%= field[:name].upcase.strip %>")\2/g'
<%- end -%>
<%- end -%>

find . -type f | xargs grep -sl WRITE_FIELD | xargs sed -i 's/WRITE_FIELD\(\s*\)(\(\s*\)OLP::RegIdx("\([a-zA-Z0-9_]*\)")\(\s*\),\(\s*\)OLP::FldOff("\([a-zA-Z0-9_]*\)")/WRITE_FIELD\1(\2"\3"\4,\5"\6"/g'
find . -type f | xargs grep -sl READ_FIELD | xargs sed -i 's/READ_FIELD\(\s*\)(\(\s*\)OLP::RegIdx("\([a-zA-Z0-9_]*\)")\(\s*\),\(\s*\)OLP::FldOff("\([a-zA-Z0-9_]*\)")/READ_FIELD\1(\2"\3"\4,\5"\6"/g'
find . -type f | xargs grep -sl COPY_FIELD | xargs sed -i 's/COPY_FIELD\(\s*\)(\(\s*\)OLP::RegIdx("\([a-zA-Z0-9_]*\)")\(\s*\),\(\s*\)OLP::FldOff("\([a-zA-Z0-9_]*\)")/COPY_FIELD\1(\2"\3"\4,\5"\6"/g'

<%- elsif type == :rb_header -%>
<%= rb_header -%>

<%= rb_header_basic -%>

<%- registers.each do |register| -%>
<%= register[:name].upcase %>_REG_INDEX = <%= register[:index] %>
<%- register[:fields].each do |field| -%>
  <%= field[:name].upcase %> = <%= field[:offset] %>
  <%= field[:width_name].upcase %> = <%= field[:width] %>
<%- end -%>
<%- end -%>

<%- end -%>
