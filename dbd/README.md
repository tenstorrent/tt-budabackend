# Buda Debug Interface and Tools

This folder contains a collection of tools to facilitate debugging of Buda runs. 
It consits of the following tools:
1. [Debuda.py](#debudapy) - used to probe the state of a Buda run in silicon.
2. [High level debugging](#high-level-debugging) - used to find data mismatch errors

## Development related information

Original [Design Documentation](https://tenstorrent.sharepoint.com/:f:/r/sites/Specifications/Spatial/Debug?csf=1&web=1&e=m6PtgT]) on Sharepoint:
- [Debug architecture](https://tenstorrent.sharepoint.com/:w:/r/sites/Specifications/Spatial/Debug/buda_debug_architecture.docx?d=w314badcf8d404f4b92e083091b0edad5&csf=1&web=1&e=EEX4UD)
- [Presentation](https://tenstorrent.sharepoint.com/:p:/r/sites/Specifications/Spatial/Debug/buda-debug-infra.pptx?d=wb835600fe80c44b79831eecb58290533&csf=1&web=1&e=r6m3Ux)

Source code path: **dbd/**.
Main development branch: **ihamer/debuda**.

List of all [Debuda issues](https://yyz-gitlab.local.tenstorrent.com/tenstorrent/budabackend/-/issues?scope=all&state=opened&label_name[]=Debuda). Gitlab issues label: **debuda**.

`slack channel`: #debuda

## Debuda.py

Debuda.py can be used to probe the state of a Buda run in silicon. Currently, it can show
details of NOC state, and status of various Queues (DRAM, Host, Epoch). It can also be used
to do random NOC reads (in case one knows the exact address of a register or memory location).
It can analyze the status of all streams and report the ones that appear hung.

**Detailed usage instructions can be found in [The User Manual](http://yyz-webservice-02.local.tenstorrent.com/docs/debuda-docs/)**

The user manual is generated by running `make dbd/docs/public`. Make sure to be able to run debuda.py before generating the docs, as the documentation generation process runs debuda.py. The output is placed in `dbd/docs/public/build/html/index.html`.

To publish the documentation, run make `make dbd/docs/public/publish`. This will copy the docs to `yyz-webservice-02:/var/www/html/docs/debuda-docs`.

### Implementation

The implementation consists of two parts: the client (debuda.py) and the debug server (a.k.a. debuda-stub). The two communicate over TCP using [ZeroMQ](https://zeromq.org/) messaging library.

![High level diagram](dbd/docs/images/debuda.png)

### Profiling

Use pyinstrument for simple profiling. Simply, prefix your invocation of Debuda with **pyinstrument**.

### Building Debuda Server
```
make dbd
```



## High Level Debugging

While debuda can help find low level bugs on silicon, High Level Debugging (aka Tapout Sweep) is used to find data mismatch errors. It runs a netlist iteratively with each operation 'tapped out' in topological order. The result of the tapped-out operation is compared with the golden results. Two flows are supported: budabackend and pybuda.

### Usage

From BudaBackEnd:
```
dbd/tapout_sweep.py --test_command "command" --out_dir output

ex.
dbd/tapout_sweep.py --test_command "build/test/verif/op_tests/test_op --netlist verif/op_tests/netlists/netlist_matmul_op_with_fd.yaml --seed 0 --silicon --timeout 500" --out_dir tapout_output
```

From PyBuda:
```
dbd/pybuda_tapout_sweep.py "pytest_command" --out_dir output

ex.
dbd/pybuda_tapout_sweep.py "pytest -svv ../../pybuda/test/backend/test_bert.py::test_encoder[inference-Grayskull-cfg0-no_recompute]" --out_dir debuda_temp
```
### How it works
It runs the provided command a number of times. Each time, it modifies the netlist by adding a DRAM queue to the output of a particular operation. This makes the result of the operation observable and comparable to golden restults. The output of the command log is examined and PASS/FAIL condition printed. Currently, the only supported command for parsing output and automatically providing correctness of operations is ***verif/op_tests/test_op***. If the output of the operation does not match golden results, the Op will be logged as failed. The Log is stored in "<span style="color:green">output_directory/tapout_result.log</span>". An entry in this file looks like this:
```
	Command: build/test/verif/op_tests/test_op --seed 0 --silicon --timeout 500 --netlist tapout_output/fwd_0_norm_ff_0_recip.yaml --pytorch-bin /home/ihamer/work/pybuda/third_party/budabackend/tapout_output/pybuda_test_backend_test_bert_py_test_encoder_inference-Grayskull-cfg0-no_recompute
	Log:tapout_output/fwd_0_norm_ff_0_recip.log
op_name: norm_ff_0_recip_s_brcst_m1_0_0.lc1
	Result: FAILED
```
 All run logs are also saved so that comparison results can be examined. 

## Slicing Netlist
tt_netlist_slicer.py is tool that helps you to cut specific part of the graph, by providing inputs/outputs.

We will demonstrate netlist slicing on [softmax](../verif/graph_tests/netlists/netlist_softmax_single_tile.yaml).

```
                                  0
                            ┌───────────────────────────────────────────────────┐
                            │                                                   ▼
┌──────────────────┐  0   ┌─────┐  0   ┌────────────────┐  0   ┌───────┐  1   ┌──────┐  0   ┌────────────────┐
│ input_activation │ ───▶ │ exp │ ───▶ │      sum       │ ───▶ │ recip │ ───▶ │ mult │ ───▶ │ output_softmax │
└──────────────────┘      └─────┘      └────────────────┘      └───────┘      └──────┘      └────────────────┘
                                         ▲
                                         │ 1
                                         │
                                       ┌────────────────┐
                                       │ input_constant │
                                       └────────────────┘

```

First example will show how to get graph with only one operation.
``` bash
./dbd/tt_netlist_slicer.py --netlist verif/graph_tests/netlists/netlist_softmax_single_tile.yaml --out_ops "mult" --in_op_inputs "mult"
```
```
┌─────────┐  0   ┌───────────┐  0   ┌──────────┐
│ DBG_exp │ ───▶ │   mult    │ ───▶ │ DBG_mult │
└─────────┘      └───────────┘      └──────────┘
                   ▲
                   │ 1
                   │
                 ┌───────────┐
                 │ DBG_recip │
                 └───────────┘
```
Second example shows how to tapout only specific operation, by leaving only necessary operations. 
``` bash
./dbd/tt_netlist_slicer.py --netlist verif/graph_tests/netlists/netlist_softmax_single_tile.yaml --out_ops "recip"
```
```

┌──────────────────┐  0   ┌─────┐  0   ┌────────────────┐  0   ┌───────┐  0   ┌───────────┐
│ input_activation │ ───▶ │ exp │ ───▶ │      sum       │ ───▶ │ recip │ ───▶ │ DBG_recip │
└──────────────────┘      └─────┘      └────────────────┘      └───────┘      └───────────┘
                                         ▲
                                         │ 1
                                         │
                                       ┌────────────────┐
                                       │ input_constant │
                                       └────────────────┘
```
Last examle shows how to replace only specific operations with input queues.
``` bash
./dbd/tt_netlist_slicer.py --netlist verif/graph_tests/netlists/netlist_softmax_single_tile.yaml --in_ops "sum exp"
```
```
┌─────────┐  0   ┌───────┐  0   ┌────────────────┐
│ DBG_exp │ ───▶ │ mult  │ ───▶ │ output_softmax │
└─────────┘      └───────┘      └────────────────┘
                   ▲
                   │ 1
                   │
┌─────────┐  0   ┌───────┐
│ DBG_sum │ ───▶ │ recip │
└─────────┘      └───────┘

```

